(self.webpackChunk=self.webpackChunk||[]).push([[2608],{52608:(e,t,n)=>{"use strict";n.r(t),n.d(t,{meshFeatureSetFromJSON:()=>ae}),n(33807);var r=n(73574),o=n(80219),i=n(98548),s=n(78155),a=n(20215),l=n(80987),c=n(88903),u=n(60816),f=n(20736),p=n(36154),h=n(84320),g=n(7571),m=n(95186),d=n(62654),x=n(71542),y=n(65352),v=n(32892),w=n(93242),b=n(52737);n(82906),n(40130),n(4169),n(52957),n(29126),n(31531),n(92858),n(6585),n(3621),n(63358),n(62121),n(81135),n(94527),n(17762),n(61888),n(29832),n(31516),n(52109),n(89710),n(65311),n(67726),n(15346),n(87405),n(78082),n(93450),n(58404),n(47365),n(67079);const A=o.n.getLogger("esri.geometry.support.meshUtils.centerAt");const R=(0,u.n)(),F=(0,u.n)();function M(e){const t=(0,l.h)(e.url);return n=>{var r;const o=(0,l.W)(n,t,t),i=o?o.replace(/^ *\.\//,""):null;return null!=(r=e.files.get(i))?r:n}}async function O(e,t){return e instanceof Blob?P.fromBlob(e):"string"==typeof e?new P(e):Array.isArray(e)?async function(e,t){const n=new Map;let r=null;const i=await(0,a.k)(e.map((async e=>({name:e.name,source:await O(e instanceof Blob?e:e.source,t)})))),s=[];for(const e of i)e&&((0,a.b)(t)?e.source.dispose():s.push(e));(0,a.a)(t);for(const{name:e,source:t}of s)((0,o.t)(r)||/\.(gltf|glb)/i.test(e))&&(r=t.url),n.set(e,t.url),t.files&&t.files.forEach(((e,t)=>n.set(t,e)));if((0,o.t)(r))throw new a.s("mesh-load-external:missing-files","Missing files to load external mesh source");return new P(r,(()=>s.forEach((({source:e})=>e.dispose()))),n)}(e,t):async function(e,t){const{default:r}=await(0,a.d)(Promise.resolve().then(n.bind(n,80987)).then((function(e){return e.K})),t),o="string"==typeof e.multipart[0]?await Promise.all(e.multipart.map((async e=>(await r(e,{responseType:"array-buffer"})).data))):e.multipart;return P.fromBlob(new Blob(o))}(e,t)}class P{constructor(e,t=(()=>{}),n=new Map){this.url=e,this.dispose=t,this.files=n}static fromBlob(e){const t=URL.createObjectURL(e);return new P(t,(()=>URL.revokeObjectURL(t)))}}const L=o.n.getLogger("esri.geometry.support.meshUtils.offset");function z(e,t){if(e)for(let n=0;n<e.length;n+=3)for(let r=0;r<3;r++)e[n+r]+=t[r]}const C=(0,u.n)(),k=(0,x.e)(),S=(0,d.e)(),I={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[3,1,2],west:[-3,-1,2],north:[-1,3,2],south:[1,-3,2],up:[1,2,3],down:[1,-2,-3]}};function j(e,t,n){(function(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5})(e),function(e,t){if(null==t)return;const n="number"==typeof t?[t,t,t]:[null!=t.width?t.width:1,null!=t.depth?t.depth:1,null!=t.height?t.height:1];E[0]=n[0],E[4]=n[1],E[8]=n[2];for(let t=0;t<e.position.length;t+=3){for(let n=0;n<3;n++)B[n]=e.position[t+n];(0,u.L)(B,B,E);for(let n=0;n<3;n++)e.position[t+n]=B[n]}if(n[0]!==n[1]||n[1]!==n[2]){E[0]=1/n[0],E[4]=1/n[1],E[8]=1/n[2];for(let t=0;t<e.normal.length;t+=3){for(let n=0;n<3;n++)B[n]=e.normal[t+n];(0,u.L)(B,B,E),(0,u.j)(B,B);for(let n=0;n<3;n++)e.normal[t+n]=B[n]}}}(e,n&&n.size);const{vertexAttributes:r,transform:o}=(0,p.k)(e,t,n);return{vertexAttributes:new h.y({...r,uv:e.uv}),transform:o,components:[new h.f({faces:e.faces,material:n&&n.material||null})],spatialReference:t.spatialReference}}const $={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},U={south:0,east:1,north:2,west:3,up:4,down:5},B=(0,u.n)(),E=(0,d.e)(),T=o.n.getLogger("esri.geometry.support.meshUtils.rotate");function G(e,t,n,r=u.G){if(!(0,o.t)(e)){(0,w.r)(q),(0,w.f)(q,q,(0,p.b)(t),(0,p.v)(t));for(let t=0;t<e.length;t+=n){for(let n=0;n<3;n++)Z[n]=e[t+n]-r[n];(0,u.I)(Z,Z,q);for(let n=0;n<3;n++)e[t+n]=Z[n]+r[n]}}}const Z=(0,u.n)(),D=(0,u.n)(),N=(0,p.a)(),q=(0,x.e)(),J=(0,d.e)(),W=(0,u.n)(),X=o.n.getLogger("esri.geometry.support.meshUtils.scale");function Y(e,t,n=u.G){if(e)for(let r=0;r<e.length;r+=3){for(let t=0;t<3;t++)_[t]=e[r+t]-n[t];(0,u.d)(_,_,t);for(let t=0;t<3;t++)e[r+t]=_[t]+n[t]}}const _=(0,u.n)(),V=(0,u.n)(),K=(0,u.n)();var H;const Q=o.n.getLogger("esri.geometry.Mesh");let ee=H=class extends(l.f.LoadableMixin((0,l.d)(f.p))){constructor(e){super(e),this.components=null,this.transform=null,this.external=null,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new h.p,this.type="mesh"}initialize(){((0,o.t)(this.external)||this.vertexAttributes.position.length)&&(this.loadStatus="loaded")}get hasExtent(){return!this.loaded&&(0,o.r)(this.external)&&(0,o.r)(this.external.extent)||this.loaded&&this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0)}get boundingInfo(){const e=this.vertexAttributes.position,t=this.spatialReference;if(0===e.length||this.components&&0===this.components.length)return{extent:new i.M({xmin:0,ymin:0,zmin:0,xmax:0,ymax:0,zmax:0,spatialReference:t}),center:new f.b({x:0,y:0,z:0,spatialReference:t})};const n=(0,o.r)(this.transform)?this.transform.project(e,t):e;let r=1/0,s=1/0,a=1/0,l=-1/0,c=-1/0,u=-1/0,p=0,h=0,g=0;const m=n.length,d=1/(m/3);let x=0;for(;x<m;){const e=n[x++],t=n[x++],o=n[x++];r=Math.min(r,e),s=Math.min(s,t),a=Math.min(a,o),l=Math.max(l,e),c=Math.max(c,t),u=Math.max(u,o),p+=d*e,h+=d*t,g+=d*o}return{extent:new i.M({xmin:r,ymin:s,zmin:a,xmax:l,ymax:c,zmax:u,spatialReference:t}),center:new f.b({x:p,y:h,z:g,spatialReference:t})}}get anchor(){if((0,o.r)(this.transform))return this.transform.getOriginPoint(this.spatialReference);const e=this.boundingInfo;return new f.b({x:e.center.x,y:e.center.y,z:e.extent.zmin,spatialReference:this.spatialReference})}get origin(){return(0,o.r)(this.transform)?this.transform.getOriginPoint(this.spatialReference):this.boundingInfo.center}get extent(){return!this.loaded&&(0,o.r)(this.external)&&(0,o.r)(this.external.extent)?this.external.extent.clone():this.boundingInfo.extent}addComponent(e){this.loaded?(this.components||(this.components=[]),this.components.push(h.f.from(e)),this.notifyChange("components")):Q.error("addComponent()","Mesh must be loaded before applying operations")}removeComponent(e){if(this.loaded){if(this.components){const t=this.components.indexOf(e);if(-1!==t)return this.components.splice(t,1),void this.notifyChange("components")}Q.error("removeComponent()","Provided component is not part of the list of components")}else Q.error("removeComponent()","Mesh must be loaded before applying operations")}rotate(e,t,n,r){return(0,p.c)(te.x,e,ne),(0,p.c)(te.y,t,re),(0,p.c)(te.z,n,oe),(0,p.q)(ne,re,ne),(0,p.q)(ne,oe,ne),function(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position||0===t[3])return;const r=e.spatialReference;if((0,o.r)(e.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&T.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,u.a)(Z,n.x,n.y,n.z),o=(0,u.c)(Z,r,e.origin);e.applyLocalInverse(o,D),e.rotation=(0,p.q)(e.rotation,t,(0,p.a)()),e.applyLocalInverse(o,o),(0,u.c)(o,o,D),e.translation=(0,u.u)((0,u.n)(),e.translation,o)}(e.transform,t,o)}else{var s;const r=null!=(s=null==n?void 0:n.origin)?s:e.origin;(0,p.r)(e.spatialReference,n)?function(e,t,n){const r=e.spatialReference,i=(0,y.e)(r),s=W;(0,g.R)(n,s,i)||(0,g.R)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,f=new Float64Array(a.length),h=(0,o.r)(l)?new Float32Array(l.length):null,d=(0,o.r)(c)?new Float32Array(c.length):null;(0,g.S)(i,s,q,i),(0,m.a)(J,q);const x=N;(0,u.L)((0,p.v)(N),(0,p.v)(t),J),x[3]=t[3],(0,v.v)(a,r,f),(0,o.r)(l)&&(0,v.F)(l,a,f,r,h),(0,o.r)(c)&&(0,v.B)(c,a,f,r,d),G(f,x,3,s),(0,v.M)(f,a,r),(0,o.r)(l)&&(G(h,x,3),(0,v._)(h,a,f,r,l)),(0,o.r)(c)&&(G(d,x,4),(0,v.R)(d,a,f,r,c)),e.vertexAttributesChanged()}(e,t,r):function(e,t,n){const r=W;if(!(0,g.R)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,T.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}G(e.vertexAttributes.position,t,3,r),G(e.vertexAttributes.normal,t,3),G(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}(e,t,r)}}(this,ne,r),this}offset(e,t,n,r){return this.loaded?(ie[0]=e,ie[1]=t,ie[2]=n,function(e,t,n){e.vertexAttributes&&e.vertexAttributes.position&&((0,o.r)(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&L.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t){const n=e.origin;e.origin=(0,u.u)((0,u.n)(),n,t)}(e.transform,t)):(0,p.r)(e.spatialReference,n)?function(e,t){const n=e.spatialReference,r=e.vertexAttributes.position,i=e.vertexAttributes.normal,s=e.vertexAttributes.tangent,a=new Float64Array(r.length),l=(0,o.r)(i)?new Float32Array(i.length):null,c=(0,o.r)(s)?new Float32Array(s.length):null,f=e.extent.center,p=C;(0,g.S)(n,[f.x,f.y,f.z],k,(0,y.e)(n)),(0,m.a)(S,k),(0,u.L)(p,t,S),(0,v.v)(r,n,a),(0,o.r)(i)&&(0,v.F)(i,r,a,n,l),(0,o.r)(s)&&(0,v.B)(s,r,a,n,c),z(a,p),(0,v.M)(a,r,n),(0,o.r)(i)&&(0,v._)(l,r,a,n,i),(0,o.r)(s)&&(0,v.R)(c,r,a,n,s),e.vertexAttributesChanged()}(e,t):function(e,t){z(e.vertexAttributes.position,t),e.vertexAttributesChanged()}(e,t))}(this,ie,r),this):(Q.error("offset()","Mesh must be loaded before applying operations"),this)}scale(e,t){return this.loaded?(function(e,t,n){if(!e.vertexAttributes||!e.vertexAttributes.position)return;const r=e.spatialReference;if((0,o.r)(e.transform)){var i;null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&X.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`);const o=null!=(i=null==n?void 0:n.origin)?i:e.transform.getOriginPoint(r);!function(e,t,n){const r=(0,u.a)(_,n.x,n.y,n.z),o=(0,u.c)(_,r,e.origin);e.applyLocalInverse(o,V);const i=(0,u.d)((0,u.n)(),e.scale,t);e.scale=i,e.applyLocalInverse(o,o),(0,u.c)(o,o,V),e.translation=(0,u.u)((0,u.n)(),e.translation,o)}(e.transform,t,o)}else{const r=(0,p.r)(e.spatialReference,n),i=n&&n.origin||e.origin;r?function(e,t,n){const r=e.spatialReference,i=(0,y.e)(r),s=K;(0,g.R)(n,s,i)||(0,g.R)(e.origin,s,i);const a=e.vertexAttributes.position,l=e.vertexAttributes.normal,c=e.vertexAttributes.tangent,u=new Float64Array(a.length),f=(0,o.r)(l)?new Float32Array(l.length):null,p=(0,o.r)(c)?new Float32Array(c.length):null;(0,v.v)(a,r,u),(0,o.r)(l)&&(0,v.F)(l,a,u,r,f),(0,o.r)(c)&&(0,v.B)(c,a,u,r,p),Y(u,t,s),(0,v.M)(u,a,r),(0,o.r)(l)&&(0,v._)(f,a,u,r,l),(0,o.r)(c)&&(0,v.R)(p,a,u,r,c),e.vertexAttributesChanged()}(e,t,i):function(e,t,n){const r=K;if(!(0,g.R)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,X.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}Y(e.vertexAttributes.position,t,r),e.vertexAttributesChanged()}(e,t,i)}}(this,e,t),this):(Q.error("scale()","Mesh must be loaded before applying operations"),this)}centerAt(e,t){return this.loaded?(function(e,t,n){var r;if(!e.vertexAttributes||!e.vertexAttributes.position)return;const i=null!=(r=null==n?void 0:n.origin)?r:e.origin;(0,o.r)(e.transform)?(null!=(null==n?void 0:n.geographic)&&n.geographic!==e.transform.geographic&&A.warn(`Specifying the 'geographic' parameter (${n.geographic}) different from the Mesh transform setting (${e.transform.geographic}) is not supported`),function(e,t,n){const r=t.x-n.x,o=t.y-n.y,i=t.hasZ&&n.hasZ?t.z-n.z:0,s=e.origin;e.origin=[s[0]+r,s[1]+o,s[2]+i]}(e.transform,t,i)):(0,p.r)(e.spatialReference,n)?function(e,t,n){const r=(0,p.M)(e.vertexAttributes,n,{geographic:!0}),{position:o,normal:i,tangent:s}=(0,p.x)(r,t,{geographic:!0});e.vertexAttributes.position=o,e.vertexAttributes.normal=i,e.vertexAttributes.tangent=s,e.vertexAttributesChanged()}(e,t,i):function(e,t,n){const r=F,o=R;if((0,g.R)(t,o,e.spatialReference)){if(!(0,g.R)(n,r,e.spatialReference)){const t=e.origin;r[0]=t.x,r[1]=t.y,r[2]=t.z,A.error(`Failed to project specified origin (wkid:${n.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid}).`)}(function(e,t,n){if(e)for(let r=0;r<e.length;r+=3)for(let o=0;o<3;o++)e[r+o]+=t[o]-n[o]})(e.vertexAttributes.position,o,r),e.vertexAttributesChanged()}else A.error(`Failed to project centerAt location (wkid:${t.spatialReference.wkid}) to mesh spatial reference (wkid:${e.spatialReference.wkid})`)}(e,t,i)}(this,e,t),this):(Q.error("centerAt()","Mesh must be loaded before applying operations"),this)}load(e){return(0,o.r)(this.external)&&this.addResolvingPromise(async function(e,t,r){const{loadGLTFMesh:i}=await(0,a.d)(n.e(3944).then(n.bind(n,73944)),r),s=await O(t,r),l=i(new f.b({x:0,y:0,z:0,spatialReference:e.spatialReference}),s.url,{resolveFile:M(s),useTransform:!0,signal:(0,o.r)(r)?r.signal:null});l.then((()=>s.dispose()),(()=>s.dispose()));const{vertexAttributes:c,components:u}=await l;e.vertexAttributes=c,e.components=u}(this,this.external.source,e)),Promise.resolve(this)}clone(){const e=this.components?new Map:null,t=this.components?new Map:null,n={components:this.components?this.components.map((n=>n.cloneWithDeduplication(e,t))):null,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes.clone(),transform:(0,o.r)(this.transform)?this.transform.clone():null,external:(0,o.r)(this.external)?{source:this.external.source,extent:(0,o.r)(this.external.extent)?this.external.extent.clone():null}:null};return new H(n)}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const{toBinaryGLTF:t}=await n.e(2254).then(n.bind(n,62254));return t(this,e)}static createBox(e,t){if(!(e instanceof f.b))return Q.error(".createBox()","expected location to be a Point instance"),null;const n=new H(j(function(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:n}=$,r=4*e.length,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array(2*e.length*3);let l=0,c=0,u=0,f=0;for(let r=0;r<e.length;r++){const p=e[r],h=l/3;for(const e of t)a[f++]=h+e;const g=p.corners;for(let e=0;e<4;e++){const t=g[e];let r=0;s[u++]=.25*n[e][0]+p.uvOrigin[0],s[u++]=p.uvOrigin[1]-.25*n[e][1];for(let e=0;e<3;e++)0!==p.axis[e]?(o[l++]=.5*p.axis[e],i[c++]=p.axis[e]):(o[l++]=.5*t[r++],i[c++]=0)}}return{position:o,normal:i,uv:s,faces:a}}(),e,t));return t&&t.imageFace&&"all"!==t.imageFace?function(e,t){const n=e.components[0],r=n.faces,i=U[t],s=6*i,a=new Uint32Array(6),l=new Uint32Array(r.length-6);let c=0,u=0;for(let e=0;e<r.length;e++)e>=s&&e<s+6?a[c++]=r[e]:l[u++]=r[e];if((0,o.r)(e.vertexAttributes.uv)){const t=new Float32Array(e.vertexAttributes.uv),n=4*i*2,r=[0,1,1,1,1,0,0,0];for(let e=0;e<r.length;e++)t[n+e]=r[e];e.vertexAttributes.uv=t}return e.components=[new h.f({faces:a,material:n.material}),new h.f({faces:l})],e}(n,t.imageFace):n}static createSphere(e,t){return e instanceof f.b?new H(j(function(e=0){const t=Math.round(8*2**e),n=2*t,r=(t-1)*(n+1)+2*n,o=new Float64Array(3*r),i=new Float32Array(3*r),s=new Float32Array(2*r),a=new Uint32Array((t-1)*n*2*3);let l=0,c=0,u=0,f=0;for(let e=0;e<=t;e++){const r=e/t*Math.PI+.5*Math.PI,p=Math.cos(r),h=Math.sin(r);B[2]=h;const g=0===e||e===t,m=g?n-1:n;for(let r=0;r<=m;r++){const h=r/m*2*Math.PI;B[0]=-Math.sin(h)*p,B[1]=Math.cos(h)*p;for(let e=0;e<3;e++)o[l]=.5*B[e],i[l]=B[e],++l;s[c++]=(r+(g?.5:0))/n,s[c++]=e/t,0!==e&&r!==n&&(e!==t&&(a[u++]=f,a[u++]=f+1,a[u++]=f-n),1!==e&&(a[u++]=f,a[u++]=f-n,a[u++]=f-n-1)),f++}}return{position:o,normal:i,uv:s,faces:a}}(t&&t.densificationFactor||0),e,t)):(Q.error(".createSphere()","expected location to be a Point instance"),null)}static createCylinder(e,t){return e instanceof f.b?new H(j(function(e=0){const t=Math.round(16*2**e),n=4*(t+1)+2*t,r=new Float64Array(3*n),o=new Float32Array(3*n),i=new Float32Array(2*n),s=new Uint32Array(4*t*3);let a=0,l=0,c=0,u=0,f=0;for(let e=0;e<=5;e++){const n=0===e||5===e,p=e<=1||e>=4,h=2===e||4===e,g=n?t-1:t;for(let m=0;m<=g;m++){const d=m/g*2*Math.PI,x=n?0:.5;B[0]=x*Math.sin(d),B[1]=x*-Math.cos(d),B[2]=e<=2?.5:-.5;for(let t=0;t<3;t++)r[a++]=B[t],o[l++]=p?2===t?e<=1?1:-1:0:2===t?0:B[t]/x;i[c++]=(m+(n?.5:0))/t,i[c++]=e<=1?1*e/3:e<=3?1*(e-2)/3+1/3:1*(e-4)/3+2/3,h||0===e||m===t||(5!==e&&(s[u++]=f,s[u++]=f+1,s[u++]=f-t),1!==e&&(s[u++]=f,s[u++]=f-t,s[u++]=f-t-1)),f++}}return{position:r,normal:o,uv:i,faces:s}}(t&&t.densificationFactor||0),e,t)):(Q.error(".createCylinder()","expected location to be a Point instance"),null)}static createPlane(e,t){return e instanceof f.b?new H(j(function(e){const t=I.facingAxisOrderSwap[e],n=I.position,r=I.normal,o=new Float64Array(n.length),i=new Float32Array(r.length);let s=0;for(let e=0;e<4;e++){const e=s;for(let a=0;a<3;a++){const l=t[a],c=Math.abs(l)-1,u=l>=0?1:-1;o[s]=n[e+c]*u,i[s]=r[e+c]*u,s++}}return{position:o,normal:i,uv:new Float32Array(I.uv),faces:new Uint32Array(I.faces)}}(t&&t.facing||"up"),e,t)):(Q.error(".createPlane()","expected location to be a Point instance"),null)}static createFromPolygon(e,t){if(!(e instanceof i.j))return Q.error(".createFromPolygon()","expected polygon to be a Polygon instance"),null;const n=(0,h.o)(e);return new H({vertexAttributes:new h.p({position:n.position}),components:[new h.f({faces:n.faces,shading:"flat",material:t&&t.material||null})],spatialReference:e.spatialReference})}static async createFromGLTF(e,t,r){if(!(e instanceof f.b))throw Q.error(".createfromGLTF()","expected location to be a Point instance"),new a.s("invalid-input","Expected location to be a Point instance");const{loadGLTFMesh:o}=await(0,a.d)(n.e(3944).then(n.bind(n,73944)),r);return new H(await o(e,t,r))}static createWithExternalSource(e,t,n){var r,o,i;const s=null!=(r=null==n?void 0:n.extent)?r:null,a=null!=(o=null==n?void 0:n.transform.clone())?o:new p.O;a.origin=[e.x,e.y,null!=(i=e.z)?i:0];const l=e.spatialReference;return new H({external:{source:t,extent:s},transform:a,spatialReference:l})}static createIncomplete(e,t){var n,r;const o=null!=(n=null==t?void 0:t.transform.clone())?n:new p.O;o.origin=[e.x,e.y,null!=(r=e.z)?r:0];const i=e.spatialReference,s=new H({transform:o,spatialReference:i});return s.addResolvingPromise(Promise.reject(new a.s("mesh-incomplete","Mesh resources are not complete"))),s}};(0,s.e)([(0,c.y)({type:[h.f],json:{write:!0}})],ee.prototype,"components",void 0),(0,s.e)([(0,c.y)({type:p.O,json:{write:!0}})],ee.prototype,"transform",void 0),(0,s.e)([(0,c.y)({constructOnly:!0})],ee.prototype,"external",void 0),(0,s.e)([(0,c.y)({readOnly:!0})],ee.prototype,"hasExtent",null),(0,s.e)([(0,c.y)({readOnly:!0})],ee.prototype,"boundingInfo",null),(0,s.e)([(0,c.y)({readOnly:!0})],ee.prototype,"anchor",null),(0,s.e)([(0,c.y)({readOnly:!0})],ee.prototype,"origin",null),(0,s.e)([(0,c.y)({readOnly:!0,json:{read:!1}})],ee.prototype,"extent",null),(0,s.e)([(0,c.y)({readOnly:!0,json:{read:!1,write:!0,default:!0}})],ee.prototype,"hasZ",void 0),(0,s.e)([(0,c.y)({readOnly:!0,json:{read:!1,write:!0,default:!1}})],ee.prototype,"hasM",void 0),(0,s.e)([(0,c.y)({type:h.p,nonNullable:!0,json:{write:!0}})],ee.prototype,"vertexAttributes",void 0),ee=H=(0,s.e)([(0,c.n)("esri.geometry.Mesh")],ee);const te={x:(0,u.i)(1,0,0),y:(0,u.i)(0,1,0),z:(0,u.i)(0,0,1)},ne=(0,p.a)(),re=(0,p.a)(),oe=(0,p.a)(),ie=(0,u.n)();var se=ee;function ae(e,t,n){const i=n.features;n.features=[],delete n.geometryType;const s=b.default.fromJSON(n);s.geometryType="mesh";const a=s.spatialReference,l=(0,o.t)(e.outFields)||!e.outFields.length?()=>({}):(c=e.outFields.includes("*")?null:new Set(e.outFields),({attributes:e})=>{if(!e)return{};if(!c)return e;for(const t in e)c.has(t)||delete e[t];return e});var c;for(const e of i){const n=le(e,a,t);(0,o.r)(n)&&s.features.push(new r.h({geometry:n,attributes:l(e)}))}return s}function le(e,t,n){const{status:r,source:o}=function(e){if(!e.assetMappings)return{status:0};const t=[],n=new Map;for(const r of e.assetMappings){const e=r.seqNo,o=r.assetName,i=r.assetURL,s=r.conversionStatus;if("FAILED"===s)return{status:0};if("COMPLETED"!==s)return{status:1};if(null==e)t.push({name:o,source:i});else{const r=n.get(o);let s;r?s=r.multipart:(s=[],t.push({name:o,source:{multipart:s}}),n.set(o,{multipart:s})),s[e]=i}}return{status:2,source:t}}(e);if(0===r)return null;const s=function({attributes:e},t,{transformFieldRoles:n}){return new f.b({x:e[n.originX],y:e[n.originY],z:e[n.originZ],spatialReference:t})}(e,t,n),a=i.M.fromJSON(e.geometry);a.spatialReference=t;const l=function({attributes:e,assetMappings:t},{transformFieldRoles:n}){var r;return new p.O({translation:[e[n.translationX],e[n.translationY],e[n.translationZ]],rotation:(0,p.c)([e[n.rotationX],e[n.rotationY],e[n.rotationZ]],e[n.rotationDeg]),scale:[e[n.scaleX],e[n.scaleY],e[n.scaleZ]],geographic:!(null!=(r=t.flags)&&r.includes("PROJECT_VERTICES"))})}(e,n);return 1===r?se.createIncomplete(s,{extent:a,transform:l}):se.createWithExternalSource(s,o,{extent:a,transform:l})}}}]);