(self.webpackChunk=self.webpackChunk||[]).push([[2143],{32143:(e,r,a)=>{"use strict";a.r(r),a.d(r,{fromUrl:()=>u});var t=a(80987),n=a(20215),l=a(80219),s=a(8725),o=a(74075);async function u(e){var r;const t=null==(r=e.properties)?void 0:r.customParameters,u=await async function(e,r){let a=(0,s.d)(e);if((0,l.t)(a)&&(a=await y(e,r)),(0,l.t)(a))throw new n.s("arcgis-layers:url-mismatch","The url '${url}' is not a valid arcgis resource",{url:e});const{serverType:t,sublayer:u}=a;let i;const c={FeatureServer:"FeatureLayer",StreamServer:"StreamLayer",VectorTileServer:"VectorTileLayer"};switch(t){case"MapServer":i=null!=u?"FeatureLayer":async function(e,r){return(await p(e,r)).tileInfo}(e,r).then((e=>e?"TileLayer":"MapImageLayer"));break;case"ImageServer":i=p(e,r).then((e=>{const r=e.tileInfo&&e.tileInfo.format;return e.tileInfo?!r||"LERC"!==r.toUpperCase()||e.cacheType&&"elevation"!==e.cacheType.toLowerCase()?"ImageryTileLayer":"ElevationLayer":"ImageryLayer"}));break;case"SceneServer":i=p(a.url.path,r).then((e=>{const r={Point:"SceneLayer","3DObject":"SceneLayer",IntegratedMesh:"IntegratedMeshLayer",PointCloud:"PointCloudLayer",Building:"BuildingSceneLayer"};if(e&&Array.isArray(e.layers)&&e.layers.length>0){const a=e.layers[0].layerType;if(null!=r[a])return r[a]}return"SceneLayer"}));break;default:i=c[t]}const f="FeatureServer"===t,v={parsedUrl:a,Constructor:null,layerOrTableId:f?u:null,sublayerIds:null,tableIds:null},I=await i;if({FeatureLayer:!0,SceneLayer:!0}[I]&&null==u){const a=await d(e,t,r);if(f&&(v.sublayerInfos=a.layerInfos,v.tableInfos=a.tableInfos),1!==a.layerIds.length+a.tableIds.length)v.sublayerIds=a.layerIds,v.tableIds=a.tableIds;else if(f){var b,S;v.layerOrTableId=null!=(b=a.layerIds[0])?b:a.tableIds[0],v.sourceJSON=null!=(S=a.layerInfos[0])?S:a.tableInfos[0]}}return v.Constructor=await async function(e){return(0,o.a[e])()}(I),v}(e.url,t),c={...e.properties,url:e.url};if(!u.sublayerIds)return null!=u.layerOrTableId&&(c.layerId=u.layerOrTableId,c.sourceJSON=u.sourceJSON),new u.Constructor(c);const f=new((await a.e(3650).then(a.bind(a,3650))).default)({title:u.parsedUrl.title});return function(e,r,a){function t(e,t){const n={...a,layerId:e,sublayerTitleMode:"service-name"};return(0,l.r)(t)&&(n.sourceJSON=t),new r.Constructor(n)}r.sublayerIds.forEach((a=>{const n=t(a,i(r.sublayerInfos,a));e.add(n)})),r.tableIds.forEach((a=>{const n=t(a,i(r.tableInfos,a));e.tables.add(n)}))}(f,u,c),f}function i(e,r){return e?e.find((e=>e.id===r)):null}async function y(e,r){var a;const n=await p(e,r);let o=null,u=null;const i=n.type;if("Feature Layer"===i||"Table"===i?(o="FeatureServer",u=n.id):"indexedVector"===i?o="VectorTileServer":n.hasOwnProperty("mapName")?o="MapServer":n.hasOwnProperty("bandCount")&&n.hasOwnProperty("pixelSizeX")?o="ImageServer":n.hasOwnProperty("maxRecordCount")&&n.hasOwnProperty("allowGeometryUpdates")?o="FeatureServer":n.hasOwnProperty("streamUrls")?o="StreamServer":c(n)?(o="SceneServer",u=n.id):n.hasOwnProperty("layers")&&c(null==(a=n.layers)?void 0:a[0])&&(o="SceneServer"),!o)return null;const y=null!=u?(0,s.m)(e):null;return{title:(0,l.r)(y)&&n.name||(0,t.p)(e),serverType:o,sublayer:u,url:{path:(0,l.r)(y)?y.serviceUrl:(0,t.U)(e).path}}}function c(e){return(null==e?void 0:e.hasOwnProperty("store"))&&e.hasOwnProperty("id")&&"number"==typeof e.id}async function d(e,r,a){var t,n;let l,s=!1;if("FeatureServer"===r){const r=await async function(e,r){var a,t;let n=await p(e,r);n=n||{},n.layers=(null==(a=n.layers)?void 0:a.filter(f))||[];const l={serviceJSON:n};if(n.currentVersion<10.5)return l;const s=await p(e+"/layers",r);return l.layersJSON={layers:(null==s||null==(t=s.layers)?void 0:t.filter(f))||[],tables:(null==s?void 0:s.tables)||[]},l}(e,a);s=!!r.layersJSON,l=r.layersJSON||r.serviceJSON}else l=await p(e,a);const o=null==(t=l)?void 0:t.layers,u=null==(n=l)?void 0:n.tables;return{layerIds:(null==o?void 0:o.map((e=>e.id)).reverse())||[],tableIds:(null==u?void 0:u.map((e=>e.id)).reverse())||[],layerInfos:s?o:[],tableInfos:s?u:[]}}function f(e){return!e.type||"Feature Layer"===e.type}async function p(e,r){return(await(0,t.L)(e,{responseType:"json",query:{f:"json",...r}})).data}a(88903),a(98548),a(78155),a(20736),a(4169),a(92858),a(31531),a(29832)}}]);