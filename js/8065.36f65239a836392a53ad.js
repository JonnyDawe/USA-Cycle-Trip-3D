(self.webpackChunk=self.webpackChunk||[]).push([[8065],{78065:(e,t,i)=>{"use strict";i.r(t),i.d(t,{A:()=>Re,o:()=>pe}),i(33807);var s=i(78155),r=i(80219),n=i(88903),o=i(39306),a=i(32422),h=i(83731),l=i(7571),c=i(65352),d=i(60816),u=i(87405),p=i(67726),g=i(59312),m=i(79679),_=i(92858),f=i(98548),y=i(13263),v=i(71391),w=i(80987),L=i(36845),b=i(15346),S=i(20736),P=i(6585),C=i(93242),x=i(71542),V=i(58275),z=i(72105),M=i(93875),R=i(3621),A=i(50822);function G(e,t,i){const s={distance:null};return(0,o.y)(s,[e[0],e[1]],[t[0],t[1]],i),s.distance}function D(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],o=i[1]-e[1];return.5*Math.abs(s*o-r*n)}function E(e,t,i,s){const r=O;return(0,l.E)(e,s,T)&&(0,l.E)(t,s,I)&&(0,l.E)(i,s,k)?(r.setPoint(0,0,T),r.setPoint(0,1,I),r.setPoint(0,2,k),Math.abs((0,y.geodesicArea)(r,"square-meters"))):0}const T=(0,d.n)(),I=(0,d.n)(),k=(0,d.n)(),O=new f.j({rings:[[T,I,k]],spatialReference:_.k.WGS84}),j=(0,d.n)();class q{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=(0,d.n)(),this.areaCentroidRenderCoords=(0,d.n)(),this.geodesicAreaCentroidRenderCoords=(0,d.n)(),this._length=0,this._centroidRenderCoords=(0,d.n)(),this._planeWorldCoords=(0,m.n)(),this._worldUp=(0,d.n)(),this._worldTangent=(0,d.n)(),this._frame=[(0,d.n)(),(0,d.n)(),(0,d.n)()],this._pathVersion=-1,this._validMeasurement=!1,this._tempU=(0,d.n)(),this._tempV=(0,d.n)(),this._tempVec3=(0,d.n)(),this._tempSphere={center:(0,d.n)(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,t,i,s){const r=this.unitNormalizer,n=this._sceneView.renderSpatialReference,a=this.unitNormalizer.spatialReference;if(this._pathVersion===e.version&&this._validMeasurement===i)return;this._pathVersion=e.version,this._validMeasurement=i;const h=e.numVertices;this._resize(h);const u=(0,c.e)(t.spatialReference),p=(0,l.n)(t.spatialReference,u)&&(0,l.Z)(t.spatialReference),g=this.positionsGeographic,m=this.positionsWorldCoords,_=this.positionsRenderCoords,f=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{(0,l.R)(e,m[t],a),(0,l.R)(e,_[t],n),p&&((0,l.y)(e,g[t]),(0,l.R)(e,f[t],u),(0,d.j)(f[t],f[t]))}));const y=this._updatePathLengths(i);if(this.pathLength=this._length>1?new o.e(r.normalizeDistance(y),"meters"):null,p){const e=this._updateGeodesicPathLengths(i,a);this.geodesicPathLength=this._length>1?new o.e(e,"meters"):null}else this.geodesicPathLength=null;if(!i)return this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),void this.geodesicIntersectingSegments.clear();this._updateArea(t,r,n,a,s),p&&this._updateGeodesicArea(t)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,unitNormalizer:this.unitNormalizer}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push((0,d.n)()),this.positionsRenderCoords.push((0,d.n)()),this.positionsProjectedWorldCoords.push((0,g.n)()),this.positionsFittedRenderCoords.push((0,d.n)()),this.positionsGeographic.push((0,d.n)()),this.positionsSpherical.push((0,d.n)()),this.positionsStereographic.push((0,g.n)()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,i=this.pathSegmentLengths;let s=0;for(let r=0;r<this._length;++r){const n=i[r]=(0,d.q)(t[r],t[(r+1)%this._length]);(r<this._length-1||e)&&(s+=n)}return s}_updateGeodesicPathLengths(e,t){const i=this.positionsGeographic,s=this.geodesicPathSegmentLengths;let r=0;for(let n=0;n<this._length;++n){const o=s[n]=G(i[n],i[(n+1)%this._length],t);(n<this._length-1||e)&&(r+=o)}return r}_updateArea(e,t,i,s,r){const n=e.renderCoordsHelper,a=this.positionsWorldCoords,h=this.positionsRenderCoords,c=this.positionsProjectedWorldCoords,u=this.positionsFittedRenderCoords,g=this._planeWorldCoords,m=this._centroidRenderCoords;(0,o.m)(h,m),n.worldUpAtPosition(m,this._worldUp),n.worldBasisAtPosition(m,0,this._worldTangent),(0,l.P)(m,this._worldUp,i,this._worldUp,s),(0,l.P)(m,this._worldTangent,i,this._worldTangent,s),a.length>2&&function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");(0,v.am)(e[0],e[1],e[2],t)}(a,g),this.fittingMode=this._selectFittingMode(g,a,this._worldUp,r);let _=0;if("horizontal"===this.fittingMode){let e=-1/0;h.forEach(((t,i)=>{const s=n.getAltitude(h[i]);s>e&&(e=s,_=i)}))}const f=a[_];let y=g,w=this._worldTangent;"horizontal"===this.fittingMode?y=this._worldUp:"vertical"===this.fittingMode&&(y=this._tempVec3,w=this._worldUp,(0,v.an)(g,this._worldUp,y)),(0,d.h)(this._frame[2],y),(0,v.an)(w,y,this._frame[0]),(0,d._)(this._frame[1],this._frame[0],this._frame[2]),(0,d.E)(this._frame[1],this._frame[1]);const L=this._tempVec3,b=this._tempU,S=this._tempV;for(let e=0;e<this._length;++e){const t=c[e],r=u[e];(0,d.c)(L,a[e],f),(0,p.r)(t,(0,d.z)(this._frame[0],L),(0,d.z)(this._frame[1],L)),(0,d.d)(b,this._frame[0],t[0]),(0,d.d)(S,this._frame[1],t[1]),(0,d.u)(L,b,S),(0,d.u)(L,L,f),(0,l.w)(L,s,r,i)}this.perimeterLength=this._length>0?new o.e(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,(0,o.m)(u,this.areaCentroidRenderCoords),(0,l.w)(this.areaCentroidRenderCoords,i,this.areaCentroidWorldCoords,s),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?new o.e(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const t=e.renderCoordsHelper,i=this.positionsSpherical,s=this.positionsStereographic,r=this._tempVec3,n=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if((0,d.z)(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&(0,d.h)(t,e[0]),!0;(0,d.a)(j,0,0,0);for(let t=0;t<e.length;++t)(0,d.u)(j,j,e[t]);if((0,d.j)(j,j),s(e,j))return t&&(0,d.h)(t,j),!0;if(!i)return!1;for(let i=0;i<e.length;++i)for(let r=0;r<e.length;++r)if(i!==r&&((0,d._)(j,e[i],e[r]),(0,d.j)(j,j),s(e,j)))return t&&(0,d.h)(t,j),!0;return!1}(i,r);if(!n)return void(this.geodesicArea=null);const a=this._tempU,h=this._tempV;(0,v.ao)(r,a,h);for(let e=0;e<this._length;++e){const t=(0,d.z)(i[e],a),n=(0,d.z)(i[e],h),o=(0,d.z)(i[e],r);(0,p.r)(s[e],t/o,n/o)}(0,d.d)(r,r,(0,c.p)(e.spatialReference).radius),t.toRenderCoords(r,(0,c.e)(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=n&&0===this.geodesicIntersectingSegments.size?new o.e(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let i=0;for(let s=0;s<this._length;++s)i+=t[s]=(0,p.d)(e[s],e[(s+1)%this._length]);return i}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],o=e[s],a=e[(s+1)%this._length];(0,f.z)(r,n,o,a)&&(t.add(i),t.add(s))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=U(e,2),i=this.triangleIndices=new Uint32Array((0,u.r)(t,[],2));let s=0;for(let t=0;t<i.length;t+=3)s+=D(e[i[t]],e[i[t+1]],e[i[t+2]]);return s}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let i=0;i<this._length;++i)for(let s=i+2;s<this._length;++s){if((s+1)%this._length===i)continue;const r=e[i],n=e[(i+1)%this._length],o=e[s],a=e[(s+1)%this._length];(0,f.z)(r,n,o,a)&&(t.add(i),t.add(s))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=U(this.positionsStereographic,2),i=this.geodesicTriangleIndices=new Uint32Array((0,u.r)(t,[],2));let s=0;for(let t=0;t<i.length;t+=3)s+=E(e[i[t]],e[i[t+1]],e[i[t+2]],_.k.WGS84);return s}_selectFittingMode(e,t,i,s){const r=t.map((t=>Math.abs(function(e,t){return(0,d.z)(e,t)+e[3]}(e,t)))).reduce(((e,t)=>Math.max(e,t)),0);!function(e,t){const i=t.center;(0,d.a)(i,0,0,0);for(let t=0;t<e.length;++t)(0,d.u)(i,i,e[t]);(0,d.d)(i,i,1/e.length);let s=0;for(let t=0;t<e.length;++t)s=Math.max(s,(0,d.D)(i,e[t]));t.radius=Math.sqrt(s)}(t,this._tempSphere);const n=r/(2*this._tempSphere.radius),o=n<s.maxRelativeErrorCoplanar,a=n<s.maxRelativeErrorAlmostCoplanar;let h="horizontal";return o?h="oblique":a&&(h=Math.abs((0,d.z)(i,e))>Math.cos((0,d.g)(s.verticalAngleThreshold))?"horizontal":"vertical"),h}}function U(e,t){const i=new Float64Array(e.length*t);for(let s=0;s<e.length;++s){const r=e[s];for(let e=0;e<t;++e)i[s*t+e]=r[e]}return i}let W=class extends s.p{constructor(e){super(e),this._handles=new h.u}initialize(){const e=this.view.spatialReference,t=(0,c.e)(e),i=t===c.a?c.b:t,s=!e||(0,l.n)(e,i)?i:e,r=new o.t(s);this._measurementDataManager=new q(this.view,r),this._handles.add(this.layerViewData.path.on("change",(()=>this._update()))),this._update()}destroy(){this._handles=(0,r.k)(this._handles)}_update(){const e=this.layerViewData;this._measurementDataManager.update(e.path,this.view,e.validMeasurement,{maxRelativeErrorCoplanar:.005,maxRelativeErrorAlmostCoplanar:.01,verticalAngleThreshold:80});const t=this._measurementDataManager.getData();this._set("measurementData",t),e.measurementData=t}};(0,s.e)([(0,n.y)({constructOnly:!0})],W.prototype,"view",void 0),(0,s.e)([(0,n.y)({constructOnly:!0})],W.prototype,"analysis",void 0),(0,s.e)([(0,n.y)({readOnly:!0})],W.prototype,"measurementData",void 0),(0,s.e)([(0,n.y)({constructOnly:!0})],W.prototype,"layerViewData",void 0),W=(0,s.e)([(0,n.n)("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementController")],W);const F=(0,g.n)();class H{constructor(e,t){this.spatialReference=e,this.viewingMode=t,this._unnormalizationInfo=Y(e,t)}tag(e){return e}createNew(){return this.tag((0,g.n)())}fromPoint(e){return this.tag((0,g.t)(e.x,e.y))}fromArray(e){return this.tag((0,g.t)(e[0],e[1]))}toArray(e){return[e[0],e[1]]}clone(e){return this.tag((0,g.e)(e))}copy(e,t){return(0,p.a)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.hasZ=!1,t.hasM=!1,t.spatialReference=this.spatialReference,t}createPoint(e){return new S.b({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new S.b({x:e[0],y:e[1],z:void 0,m:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:void 0,m:void 0,hasZ:!1,hasM:!1,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return(0,p.y)(s,e,t,i)}addDelta(e,t,i){e[0]+=t,e[1]+=i}scale(e,t,i,s){const r=(0,p.o)(F,e,t),n=(0,p.l)(F,i,(0,p._)(i,r));(0,p.m)(e,e,n,s-1)}rotate(e,t,i){(0,p.L)(e,e,t,i)}pointToArray(e){return[e.x,e.y]}getZ(e,t){return t}hasZ(){return!1}getM(e,t){return t}hasM(){return!1}unnormalize(e){X(e,this._unnormalizationInfo)}fromXYZ(e){return this.tag((0,g.t)(e[0],e[1]))}toXYZ(e,t=0){return(0,d.i)(e[0],e[1],t)}distance(e,t){return(0,p.d)(e,t)}}class Z{constructor(e,t,i){this.valueType=e,this.spatialReference=t,this._unnormalizationInfo=Y(t,i)}distance(e,t){return 0===this.valueType?(0,d.q)(e,t):(0,p.d)(e,t)}tag(e){return e}createNew(){return this.tag((0,d.n)())}fromPoint(e){return this.tag((0,d.i)(e.x,e.y,0===this.valueType?e.z:e.m))}fromArray(e){return this.tag((0,d.i)(e[0],e[1],e[2]||0))}toArray(e){return[e[0],e[1],e[2]]}clone(e){return this.tag((0,d.M)(e))}copy(e,t){return(0,d.h)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],0===this.valueType?(t.z=e[2],t.hasZ=!0,t.hasM=!1):(t.m=e[2],t.hasZ=!1,t.hasM=!0),t.spatialReference=this.spatialReference,t}createPoint(e){return new S.b({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createPointFromArray(e){return new S.b({x:e[0],y:e[1],z:0===this.valueType?e[2]:void 0,m:1===this.valueType?e[2]:void 0,spatialReference:this.spatialReference})}createDehydratedPoint(e){const t=0===this.valueType,i=1===this.valueType;return{x:e[0],y:e[1],z:t?e[2]:void 0,m:i?e[2]:void 0,hasZ:t,hasM:i,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return(0,d.y)(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,0===this.valueType&&(e[2]+=s)}scale(e,t,i,s){const r=(0,p.o)(F,e,t),n=(0,p.l)(F,i,(0,p._)(i,r));(0,p.m)(e,e,n,s-1)}rotate(e,t,i){(0,p.L)(e,e,t,i)}pointToArray(e){return 0===this.valueType?[e.x,e.y,e.z]:[e.x,e.y,e.m]}getZ(e,t){return 0===this.valueType?e[2]:t}hasZ(){return 0===this.valueType}getM(e,t){return 1===this.valueType?e[2]:t}hasM(){return 1===this.valueType}unnormalize(e){X(e,this._unnormalizationInfo)}fromXYZ(e,t=0,i=0){return this.tag((0,d.i)(e[0],e[1],0===this.valueType?e.length>2?e[2]:t:i))}toXYZ(e,t=0){return this.tag((0,d.i)(e[0],e[1],0===this.valueType?e[2]:t))}}class B{constructor(e,t){this.spatialReference=e,this._unnormalizationInfo=Y(e,t)}distance(e,t){return(0,d.q)(e,t)}tag(e){return e}createNew(){return this.tag((0,m.n)())}fromPoint(e){return this.tag((0,m.a)(e.x,e.y,e.z,e.m))}fromArray(e){return this.tag((0,m.a)(e[0],e[1],e[2]||0,e[3]||0))}toArray(e){return[e[0],e[1],e[2],e[3]]}clone(e){return this.tag((0,m.e)(e))}copy(e,t){return(0,b.a)(t,e)}toPoint(e,t){return t.x=e[0],t.y=e[1],t.z=e[2],t.m=e[3],t.hasZ=!0,t.hasM=!0,t.spatialReference=this.spatialReference,t}createPoint(e){return new S.b({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createPointFromArray(e){return new S.b({x:e[0],y:e[1],z:e[2],m:e[3],spatialReference:this.spatialReference})}createDehydratedPoint(e){return{x:e[0],y:e[1],z:e[2],m:e[3],hasZ:!0,hasM:!0,spatialReference:this.spatialReference,type:"point"}}lerp(e,t,i,s){return(0,b.j)(s,e,t,i)}addDelta(e,t,i,s){e[0]+=t,e[1]+=i,e[2]+=s}scale(e,t,i,s){const r=(0,p.o)(F,e,t),n=(0,p.l)(F,i,(0,p._)(i,r));(0,p.m)(e,e,n,s-1)}rotate(e,t,i){(0,p.L)(e,e,t,i)}pointToArray(e){return[e.x,e.y,e.z,e.m]}getZ(e){return e[2]}hasZ(){return!0}getM(e){return e[3]}hasM(){return!0}unnormalize(e){X(e,this._unnormalizationInfo)}fromXYZ(e,t=0,i=0){return this.tag((0,m.a)(e[0],e[1],e.length>2?e[2]:t,i))}toXYZ(e){return(0,d.i)(e[0],e[1],e[2])}}function N(e,t,i,s){return e&&t?new B(i,s):t?new Z(1,i,s):e?new Z(0,i,s):new H(i,s)}function X(e,t){if(!t.supported)return;let i=1/0,s=-1/0;const r=t.upperBoundX-t.lowerBoundX;e.forEach((e=>{let n=e.pos[0];for(;n<t.lowerBoundX;)n+=r;for(;n>t.upperBoundX;)n-=r;i=Math.min(i,n),s=Math.max(s,n),e.pos[0]=n}));const n=s-i;r-n<n&&e.forEach((e=>{e.pos[0]<0&&(e.pos[0]+=r)}))}function Y(e,t){const i=(0,_.S)(e);return"global"===t&&i?{supported:!0,lowerBoundX:i.valid[0],upperBoundX:i.valid[1]}:{supported:!1,lowerBoundX:null,upperBoundX:null}}class ${constructor(e){this.left=null,this.right=null,this.type="vertex",this.index=null,this.component=e}get pos(){return this._pos}set pos(e){this._pos=e,this.component.unnormalizeVertexPositions()}}class J{constructor(e,t,i){this.type="edge",this.component=e,this.left=t,this.right=i,t.right=this,i.left=this}}class K{constructor(e){this.vertices=[],this.edges=[],this.data=e}unnormalizeVertexPositions(){this.vertices.length<=1||this.data.coordinateHelper.unnormalize(this.vertices)}updateVertexIndex(e,t){if(0===this.vertices.length)return;const i=this.vertices[0];let s=null,r=e,n=t;do{s=r,s.index=n++,r=s.right?s.right.right:null}while(null!=r&&r!==i);s.left&&s!==this.vertices[this.vertices.length-1]&&this.swapVertices(this.vertices.indexOf(s),this.vertices.length-1)}getFirstVertex(){return 0===this.vertices.length?null:this.vertices[0]}getLastVertex(){return 0===this.vertices.length?null:this.vertices[this.vertices.length-1]}isClosed(){return this.vertices.length>2&&null!==this.vertices[0].left}swapVertices(e,t){const i=this.vertices[e];this.vertices[e]=this.vertices[t],this.vertices[t]=i}iterateVertices(e){if(0===this.vertices.length)return;const t=this.vertices[0];let i=t;do{e(i,i.index),i=(0,r.r)(i.right)?i.right.right:null}while(i!==t&&null!=i)}}class Q extends w.n{constructor(e){super(),this.coordinateHelper=e,this.undoStack=[],this.redoStack=[],this.components=[]}apply(e,t=1){return 0!==t&&!(0,r.t)(this.lastOperation)&&this.lastOperation.accumulate(e)||(e.apply(),this.undoStack.push(e),this.redoStack=[]),e}undo(){if(this.undoStack.length>0){const e=this.undoStack.pop();return e.undo(),this.redoStack.push(e),e}return null}get canUndo(){return this.undoStack.length>0}get lastOperation(){return this.undoStack.length>0?this.undoStack[this.undoStack.length-1]:null}redo(){if(this.redoStack.length>0){const e=this.redoStack.pop();return e.apply(),this.undoStack.push(e),e}return null}get canRedo(){return this.redoStack.length>0}toPoint(){return 0===this.components.length||0===this.components[0].vertices.length?null:this.coordinateHelper.createPoint(this.components[0].vertices[0].pos)}toPolyline(){const e=[],t=this.coordinateHelper.toArray;return this.components.forEach(((i,s)=>{const r=[];let n=i.vertices.find((e=>null==e.left));const o=n;do{r.push(t(n.pos)),n=n.right?n.right.right:null}while(n&&n!==o);e.push(r)})),new f.m({paths:e,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}toPolygon(){const e=[],t=this.coordinateHelper.toArray;return this.components.forEach(((i,s)=>{const n=[],o=i.vertices[0];let a=o;const h=a;do{n.push(t(a.pos)),a=(0,r.r)(a.right)?a.right.right:null}while(a&&a!==h);i.isClosed()&&n.push(t(o.pos)),e.push(n)})),new f.j({rings:e,spatialReference:this.coordinateHelper.spatialReference,hasZ:this.coordinateHelper.hasZ(),hasM:this.coordinateHelper.hasM()})}static fromGeometry(e,t){const i=N(e.hasZ,e.hasM,e.spatialReference,t),r=new Q(i);switch(e.type){case"polygon":{const t=e.rings;for(let e=0;e<t.length;++e){const n=t[e],o=new K(r),a=n.length>2&&(0,s.K)(n[0],n[n.length-1]),h=a?n.length-1:n.length;for(let e=0;e<h;++e){const t=i.fromArray(n[e]),s=new $(o);o.vertices.push(s),s.pos=t,s.index=e}const l=o.vertices.length-1;for(let e=0;e<l;++e){const t=o.vertices[e],i=o.vertices[e+1],s=new J(o,t,i);o.edges.push(s)}if(a){const e=new J(o,o.vertices[o.vertices.length-1],o.vertices[0]);o.edges.push(e)}r.components.push(o)}}break;case"polyline":for(const t of e.paths){const e=new K(r),s=t.length;for(let r=0;r<s;++r){const s=i.fromArray(t[r]),n=new $(e);e.vertices.push(n),n.pos=s,n.index=r}const n=e.vertices.length-1;for(let t=0;t<n;++t){const i=e.vertices[t],s=e.vertices[t+1],r=new J(e,i,s);e.edges.push(r)}r.components.push(e)}break;case"point":{const t=new K(r),i=new $(t);i.index=0,i.pos=r.coordinateHelper.fromPoint(e),t.vertices.push(i),r.components.push(t)}}return r}}class ee{constructor(e,t,i){this.editGeometry=e,this.component=t,this.pos=i,this.addedVertex=null,this.originalEdge=null,this.left=null,this.right=null}apply(){let e="redo";(0,r.t)(this.addedVertex)&&(e="apply",this.addedVertex=new $(this.component));const t=this.component.getLastVertex();if((0,r.t)(t))this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,this.addedVertex.index=0;else{let e=null;t.right&&(this.originalEdge=t.right,e=this.originalEdge.right,this.component.edges.splice(this.component.edges.indexOf(this.originalEdge),1)),this.component.vertices.push(this.addedVertex),this.addedVertex.pos=this.pos,(0,r.t)(this.left)&&(this.left=new J(this.component,t,this.addedVertex)),this.component.edges.push(this.left),t.right=this.left,(0,r.r)(this.originalEdge)&&(0,r.r)(e)&&((0,r.t)(this.right)&&(this.right=new J(this.component,this.addedVertex,e)),this.component.edges.push(this.right),e.left=this.right),this.component.updateVertexIndex(this.addedVertex,t.index+1)}const i={addedVertices:[this.addedVertex],operation:e};this.editGeometry.emit("change",i)}undo(){if((0,r.t)(this.addedVertex))return null;this.component.vertices.splice(this.component.vertices.indexOf(this.addedVertex),1),(0,r.r)(this.left)&&(this.component.edges.splice(this.component.edges.indexOf(this.left),1),this.left.left.right=null),(0,r.r)(this.right)&&(this.component.edges.splice(this.component.edges.indexOf(this.right),1),this.right.right.left=null),(0,r.r)(this.originalEdge)&&(this.component.edges.push(this.originalEdge),this.originalEdge.left.right=this.originalEdge,this.originalEdge.right.left=this.originalEdge),(0,r.r)(this.left)?this.component.updateVertexIndex(this.left.left,this.left.left.index):this.component.updateVertexIndex(this.addedVertex,0);const e={removedVertices:[this.addedVertex],operation:"undo"};this.editGeometry.emit("change",e)}accumulate(){return!1}}class te{constructor(e,t,i){this.editGeometry=e,this.vertex=t,this.pos=i}apply(){const e=(0,r.t)(this.originalPosition);e&&(this.originalPosition=this.vertex.pos),this._apply(e?"apply":"redo")}undo(){this.vertex.pos=(0,r.f)(this.originalPosition);const e={updatedVertices:[this.vertex],operation:"undo"};this.editGeometry.emit("change",e)}accumulate(e){return e instanceof te&&e.vertex===this.vertex&&(this.pos=e.pos,this._apply("apply"),!0)}_apply(e){this.vertex.pos=this.pos,this.editGeometry.components.forEach((e=>e.unnormalizeVertexPositions()));const t={updatedVertices:[this.vertex],operation:e};this.editGeometry.emit("change",t)}}class ie{constructor(e,t){this.editGeometry=e,this.component=t,this.createdEdge=null}apply(){let e="redo";if((0,r.t)(this.createdEdge)){e="apply";const t=this.component.getFirstVertex(),i=this.component.getLastVertex();if(this.component.isClosed()||this.component.vertices.length<3||(0,r.t)(t)||(0,r.t)(i))return;this.createdEdge=new J(this.component,i,t)}this.createdEdge.left.right=this.createdEdge,this.createdEdge.right.left=this.createdEdge,this.component.edges.push(this.createdEdge);const t={operation:e};this.editGeometry.emit("change",t)}undo(){(0,r.t)(this.createdEdge)||(this.component.edges.splice(this.component.edges.indexOf(this.createdEdge),1),this.createdEdge.left.right=null,this.createdEdge.right.left=null,this.editGeometry.emit("change",{operation:"undo"}))}accumulate(){return!1}}let se=class extends w.n.EventedAccessor{constructor(e={}){super(e),this._handles=new h.u,this._version=0,this._internalGeometryChange=!1}set areaMeasurement(e){this._set("areaMeasurement",e),(0,r.r)(e)&&(0,r.r)(this.view)&&this._initialize(e,this.view)}set view(e){this._set("view",e),(0,r.r)(e)&&(0,r.r)(this.areaMeasurement)&&this._initialize(this.areaMeasurement,e)}get initialized(){return(0,r.r)(this.areaMeasurement)&&(0,r.r)(this.view)}get version(){return this._version}get isValidPolygon(){return this.initialized&&this._editGeometry.components.length>0&&this._editGeometry.components[0].isClosed()}_initialize(e,t){this._handles.removeAll(),this._handles.add((0,L.d)(e,"geometry",(()=>this._updateEditGeometryFromModelGeometry(e,t)),!0)),this._makeDirty(!0)}_makeDirty(e=!1){this.notifyChange("isValidPolygon"),this.notifyChange("initialized"),e&&this.notifyChange("numVertices")}_updateEditGeometryFromModelGeometry(e,t){this._version++,this._internalGeometryChange||(this._handles.remove("EditGeometry"),this._editGeometry=(0,r.r)(e.geometry)?Q.fromGeometry(e.geometry,t.viewingMode):new Q(N(!0,!1,t.spatialReference,t.viewingMode)),this._makeDirty(!0),this.emit("change",{type:"change"}),this._handles.add(this._editGeometry.on("change",(t=>{this._makeDirty(null!=t.addedVertices||null!=t.removedVertices),this._internalGeometryChange=!0,e.geometry=this.numVertices>0?this._editGeometry.toPolygon():null,this._internalGeometryChange=!1})),"EditGeometry"))}get vertices(){const e=[];return this.forEachVertex((t=>{e.push(t)})),e}get numVertices(){return this.initialized&&this._editGeometry.components.length>0?this._editGeometry.components[0].vertices.length:0}get lastPoint(){if(this.initialized&&this._editGeometry.components.length>0){const e=this._editGeometry.components[0].getLastVertex();if((0,r.r)(e))return this._editGeometry.coordinateHelper.createPoint(e.pos)}return null}getVertex(e){if(!this.initialized||0===this._editGeometry.components.length||0===this._editGeometry.components[0].vertices.length)return null;const t=this._editGeometry.components[0].vertices[0];let i=t;do{if(i.index===e)return i;i=i.right.right}while(i!==t&&null!=i);return null}getVertexPositionAsPoint(e){return this._editGeometry.coordinateHelper.createPoint(e.pos)}getVertexPositionAsPointFromIndex(e){return this._editGeometry.coordinateHelper.createPoint(this.getVertex(e).pos)}forEachVertex(e){this.initialized&&this._editGeometry.components.length>0&&this._editGeometry.components[0].iterateVertices(e)}forEachVertexPosition(e){const t=this._editGeometry.coordinateHelper;this.forEachVertex(((i,s)=>{t.toPoint(i.pos,re),e(re,s)}))}clear(){(0,r.r)(this.areaMeasurement)&&(this.areaMeasurement.geometry=null)}add(e){if(!this.initialized)return null;0===this._editGeometry.components.length&&this._editGeometry.components.push(new K(this._editGeometry));const t=new ee(this._editGeometry,this._editGeometry.components[0],this._editGeometry.coordinateHelper.fromPoint(e));return this._editGeometry.apply(t),this.emit("change",{type:"change"}),t}close(){if(!this.initialized)return null;if(0===this._editGeometry.components.length)return null;const e=this._editGeometry.components[0],t=new ie(this._editGeometry,e);return this._editGeometry.apply(t),this.emit("change",{type:"change"}),t}ensureContains(e,t=""){let i=!1;if(this._editGeometry.components.forEach((t=>{t.iterateVertices((t=>{t===e&&(i=!0)}))})),!i)throw new Error(`vertex doesnt exist ${t}`);return i}setVertexPosition(e,t){if(!this.initialized)return null;const i=new te(this._editGeometry,e,this._editGeometry.coordinateHelper.fromPoint(t));return this._editGeometry.apply(i),this.emit("change",{type:"change"}),i}equals(e){if(this.numVertices!==e.numVertices)return!1;let t=!0;return this.forEachVertexPosition(((i,s)=>{const r=e.getVertexPositionAsPointFromIndex(s);i.equals(r)||(t=!1)})),!!t}};(0,s.e)([(0,n.y)({value:null})],se.prototype,"areaMeasurement",null),(0,s.e)([(0,n.y)({value:null})],se.prototype,"view",null),(0,s.e)([(0,n.y)()],se.prototype,"isValidPolygon",null),(0,s.e)([(0,n.y)()],se.prototype,"numVertices",null),se=(0,s.e)([(0,n.n)("esri.views.3d.interactive.graphics.AreaMeasurement3D.AreaMeasurement3DPathHelper")],se);const re=new S.b;let ne=class extends s.p{constructor(){super(...arguments),this.measurementData=null,this.unitNormalizer=new o.t,this.path=new se,this.lastDraggedVertex=null}destroy(){this.measurementData=null,this.path=(0,r.k)(this.path)}get validMeasurement(){return this.path.isValidPolygon}};var oe;(0,s.e)([(0,n.y)()],ne.prototype,"measurementData",void 0),(0,s.e)([(0,n.y)()],ne.prototype,"validMeasurement",null),(0,s.e)([(0,n.y)()],ne.prototype,"unitNormalizer",void 0),(0,s.e)([(0,n.y)()],ne.prototype,"path",void 0),(0,s.e)([(0,n.y)()],ne.prototype,"lastDraggedVertex",void 0),(0,s.e)([(0,n.y)()],ne.prototype,"cursorPoint",void 0),ne=(0,s.e)([(0,n.n)("esri.views.3d.layers.analysis.AreaMeasurement3D.AreaMeasurementLayerViewData")],ne),function(e){e.boundingSphere=function(e,t){const i=t.center;(0,d.a)(i,0,0,0);for(let t=0;t<e.length;++t)(0,d.u)(i,i,e[t]);(0,d.d)(i,i,1/e.length);let s=0;for(let t=0;t<e.length;++t)s=Math.max(s,(0,d.D)(i,e[t]));t.radius=Math.sqrt(s)},e.bestFitPlane=function(e,t){if(e.length<3)throw new Error("need at least 3 points to fit a plane");(0,v.am)(e[0],e[1],e[2],t)},e.planePointDistance=function(e,t){return(0,d.z)(e,t)+e[3]},e.segmentLengthEuclidean=function(e,t,i){return(0,l.R)(e,ae,i)&&(0,l.R)(t,he,i)?(0,d.q)(ae,he):0},e.segmentLengthGeodesic=function(e,t){if(!(0,l.y)(e,ae)||!(0,l.y)(t,he))return 0;const i={distance:null};return(0,o.y)(i,[ae[0],ae[1]],[he[0],he[1]]),i.distance},e.segmentLengthGeodesicVector=function(e,t,i){const s={distance:null};return(0,o.y)(s,[e[0],e[1]],[t[0],t[1]],i),s.distance},e.triangleAreaEuclidean=function(e,t,i){const s=t[0]-e[0],r=t[1]-e[1],n=i[0]-e[0],o=i[1]-e[1];return.5*Math.abs(s*o-r*n)},e.triangleAreaGeodesic=function(e,t,i,s){const r=ce;return(0,l.E)(e,s,ae)&&(0,l.E)(t,s,he)&&(0,l.E)(i,s,le)?(r.setPoint(0,0,ae),r.setPoint(0,1,he),r.setPoint(0,2,le),Math.abs((0,y.geodesicArea)(r,"square-meters"))):0},e.tangentFrame=function(e,t,i){Math.abs(e[0])>Math.abs(e[1])?(0,d.a)(t,0,1,0):(0,d.a)(t,1,0,0),(0,d._)(i,e,t),(0,d.j)(t,t),(0,d._)(t,i,e),(0,d.j)(i,i)},e.fitHemisphere=function(e,t=null,i=!0){const s=(e,t)=>{if(0===t[0]&&0===t[1]&&0===t[2])return!1;for(let i=0;i<e.length;++i)if((0,d.z)(t,e[i])<-1e-6)return!1;return!0};if(0===e.length)return!1;if(1===e.length)return t&&(0,d.h)(t,e[0]),!0;(0,d.a)(de,0,0,0);for(let t=0;t<e.length;++t)(0,d.u)(de,de,e[t]);if((0,d.j)(de,de),s(e,de))return t&&(0,d.h)(t,de),!0;if(!i)return!1;for(let i=0;i<e.length;++i)for(let r=0;r<e.length;++r)if(i!==r&&((0,d._)(de,e[i],e[r]),(0,d.j)(de,de),s(e,de)))return t&&(0,d.h)(t,de),!0;return!1},e.compareSets=function(e,t){if(e===t)return!0;if(e.size!==t.size)return!1;for(let i=0;i<e.size;++i)if(!t.has(e[i]))return!1;return!0}}(oe||(oe={}));const ae=(0,d.n)(),he=(0,d.n)(),le=(0,d.n)(),ce=new f.j({rings:[[ae,he,le]],spatialReference:_.k.WGS84}),de=(0,d.n)();var ue=oe;function pe(e){const t=new z.n;return t.extensions.add("GL_OES_standard_derivatives"),t.attributes.add("position","vec3"),t.attributes.add("uv0","vec2"),t.vertex.uniforms.add("proj","mat4").add("view","mat4"),t.varyings.add("vUV","vec2"),e.multipassTerrainEnabled&&t.varyings.add("depth","float"),t.vertex.code.add(z.t`
    void main(void) {
      vUV = uv0;
      ${e.multipassTerrainEnabled?"depth = (view * vec4(position, 1.0)).z;":""}
      gl_Position = proj * view * vec4(position, 1.0);
    }
  `),e.multipassTerrainEnabled&&(t.fragment.include(z.L),t.include(z.ap,e)),t.fragment.uniforms.add("size","vec2").add("color1","vec4").add("color2","vec4"),t.fragment.include(z.j),t.fragment.code.add(z.t`
    void main() {
      ${e.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
      vec2 uvScaled = vUV / (2.0 * size);

      vec2 uv = fract(uvScaled - 0.25);
      vec2 ab = clamp((abs(uv - 0.5) - 0.25) / fwidth(uvScaled), -0.5, 0.5);
      float fade = smoothstep(0.25, 0.5, max(fwidth(uvScaled.x), fwidth(uvScaled.y)));
      float t = mix(abs(ab.x + ab.y), 0.5, fade);

      gl_FragColor = mix(color2, color1, t);
      ${e.OITEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    }
  `),t}var ge=Object.freeze({__proto__:null,build:pe});class me extends z.c{initializeProgram(e){const t=me.shader.get(),i=this.configuration,s=t.build({OITEnabled:0===i.transparencyPassType,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new z.d(e.rctx,s,z.o)}bindPass(e,t){(0,z.h)(this.program,t.camera.projectionMatrix),this.program.setUniform2fv("size",e.size),this.program.setUniform4fv("color1",e.color1),this.program.setUniform4fv("color2",e.color2),t.multipassTerrainEnabled&&(this.program.setUniform2fv("cameraNearFar",t.camera.nearFar),this.program.setUniform2fv("inverseViewport",t.inverseViewport),(0,z.Y)(this.program,t))}bindDraw(e){(0,z.a2)(this.program,e)}setPipelineState(e){const t=this.configuration,i=3===e,s=2===e;return(0,M.g)({blending:t.transparent?i?fe:(0,z.a5)(e):null,depthTest:{func:(0,z.as)(e)},depthWrite:i?t.writeDepth&&M.l:(0,z.at)(e),colorWrite:M.r,polygonOffset:i||s?t.polygonOffset&&_e:{factor:-1,units:-25}})}initializePipeline(){return this.setPipelineState(this.configuration.transparencyPassType)}}me.shader=new z.f(ge,(()=>i.e(6284).then(i.bind(i,36284))));const _e={factor:0,units:-25},fe=(0,M.e)(770,1,771,771);class ye extends z.b{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=3,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}(0,s.e)([(0,z.a)()],ye.prototype,"transparent",void 0),(0,s.e)([(0,z.a)()],ye.prototype,"writeDepth",void 0),(0,s.e)([(0,z.a)()],ye.prototype,"polygonOffset",void 0),(0,s.e)([(0,z.a)({count:4})],ye.prototype,"transparencyPassType",void 0),(0,s.e)([(0,z.a)()],ye.prototype,"multipassTerrainEnabled",void 0),(0,s.e)([(0,z.a)()],ye.prototype,"cullAboveGround",void 0);class ve extends z.a6{constructor(e){super(e,Le),this.techniqueConfig=new ye}dispose(){}getPassParameters(){return this.params}getTechniqueConfig(e){return this.techniqueConfig.transparent=this.params.transparent,this.techniqueConfig.writeDepth=this.params.writeDepth,this.techniqueConfig.polygonOffset=this.params.polygonOffset,this.techniqueConfig.transparencyPassType=e?e.transparencyPassType:3,this.techniqueConfig.multipassTerrainEnabled=!!e&&e.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=!!e&&e.cullAboveGround,this.techniqueConfig}intersect(e,t,i,s,r,n,o){return(0,z.b9)(e,t,s,r,n,void 0,o)}getGLMaterial(e){return 0===e.output||7===e.output?new we(e):void 0}createBufferWriter(){return new a.s(a.t)}}class we extends z.aj{constructor(e){super(e),this.updateParameters()}updateParameters(e){this._technique=this._techniqueRep.releaseAndAcquire(me,this._material.getTechniqueConfig(e),this._technique)}beginSlot(e){let t=3;return this._technique.configuration.transparent&&(t=this._technique.configuration.writeDepth?5:8),e===t}ensureParameters(e){this.updateParameters(e)}bind(e){this._technique.bindPass(this._material.getPassParameters(),e)}}const Le={size:[1,1],color1:[.75,.75,.75,1],color2:[.5,.5,.5,1],transparent:!1,writeDepth:!0,polygonOffset:!1,...z.ab};class be extends V.c{constructor(e){super(e),this._checkerBoardMaterial=null,this._renderOccluded=4,this._geometry=null,this._size=[1,1],this._color1=[1,.5,0,.5],this._color2=[1,1,1,.5],this.applyProps(e)}get renderOccluded(){return this._renderOccluded}set renderOccluded(e){e!==this._renderOccluded&&(this._renderOccluded=e,this.updateMaterial())}get geometry(){return this._geometry}set geometry(e){this._geometry=e,this.geometryChanged()}get size(){return this._size}set size(e){this._size=e,this.updateMaterial()}get color1(){return this._color1}set color1(e){this._color1=e,this.updateMaterial()}get color2(){return this._color2}set color2(e){this._color2=e,this.updateMaterial()}updateMaterial(){(0,r.r)(this._checkerBoardMaterial)&&this._checkerBoardMaterial.setParameterValues({size:this._size,color1:this._color1,color2:this._color2,renderOccluded:this._renderOccluded})}createExternalResources(){this._checkerBoardMaterial=new ve({size:this._size,color1:this._color1,color2:this._color2,transparent:!0,writeDepth:!1,polygonOffset:!0,renderOccluded:4})}destroyExternalResources(){this._checkerBoardMaterial=null}forEachExternalMaterial(e){(0,r.r)(this._checkerBoardMaterial)&&e(this._checkerBoardMaterial)}createGeometries(e){if((0,r.t)(this._geometry)||(0,r.t)(this._checkerBoardMaterial))return;const t=Se;(0,C.y)(t,this.transform);const i=this._geometry,s=[],n=(0,d.n)();i.position.forEach((e=>{(0,d.c)(n,e,t),s.push(n[0],n[1],n[2])}));const o=[];i.uv.forEach((e=>{o.push(e[0],e[1])}));const a=new z.u([["position",{size:3,data:s,exclusive:!0}],["uv0",{size:2,data:o,exclusive:!0}]],[["position",i.triangleIndices],["uv0",i.triangleIndices]]);e.addGeometry(a,this._checkerBoardMaterial)}geometryChanged(){this.recreateGeometry()}}const Se=(0,d.n)();let Pe=class extends s.p{constructor(e){super(e),this._handles=new h.u,this._params={...Ce},this._path=null,this._intersectedPath=null,this._perimeter=null,this._intersectedPerimeter=null,this._projectionLines=null,this._measurementArea=null,this._areaLabel=null,this._pathLengthLabel=null,this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel=null,this._pathSegments=[],this._perimeterSegments=[],this._cursorSegment=null,this._origin=(0,d.n)(),this._originTransform=(0,x.e)(),this._cursorPositionRenderSpace=(0,d.n)(),this.messages=null,this.viewData=xe,this.areaLabel=null,this.perimeterLengthLabel=null,this.mode="auto",this.geodesicMeasurementDistanceThreshold=1e5}get visible(){return this.layerView.visible&&!this.layerView.suspended}get testData(){return{labels:{area:this._areaLabel,pathLength:this._pathLengthLabel,cursorSegmentLength:this._cursorSegmentLengthLabel,perimeterLength:this._perimeterLengthLabel}}}initialize(){const e=this.view;this._path=new V.m({view:e,attached:!0,width:this._params.pathLineWidth,color:this._params.pathLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPath=new V.m({view:e,attached:!0,width:this._params.pathLineWidth,color:this._params.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._perimeter=new V.m({view:e,attached:!0,width:this._params.perimeterLineWidth,color:this._params.perimeterLineColor,polygonOffset:!0,renderOccluded:4}),this._intersectedPerimeter=new V.m({view:e,attached:!0,width:this._params.perimeterLineWidth,color:this._params.intersectingLineColor,polygonOffset:!0,renderOccluded:4}),this._projectionLines=new V.m({view:e,attached:!0,width:this._params.projectionLineWidth,color:this._params.projectionLineColor,stipplePattern:(0,a.a5)(this._params.projectionLineStippleSize),stippleIntegerRepeats:!1,polygonOffset:!0,renderOccluded:4}),this._measurementArea=new be({view:e,attached:!0,color1:this._params.areaColor1,color2:this._params.areaColor2}),this._areaLabel=new o.v({view:this.view,attached:!0,fontSize:16}),this._pathLengthLabel=new o.v({view:e,attached:!0,fontSize:12}),this._cursorSegmentLengthLabel=new o.v({view:e,attached:!0,fontSize:12}),this._perimeterLengthLabel=new o.v({view:e,attached:!0,fontSize:12});const t=this.layerView,i=t.layerViewData;this._handles.add([(0,s.N)((()=>[this.mode,this.visible,t.unit,i.measurementData,i.cursorPoint]),(()=>this._update())),(0,s.N)((()=>{var t;return null==(t=e.state)?void 0:t.camera}),(()=>this._updateLabels())),(0,R.g)((async()=>this._updateMessageBundle()))]),this._updateMessageBundle()}destroy(){this._measurementArea.destroy(),this._measurementArea=null,this._path.destroy(),this._path=null,this._intersectedPath.destroy(),this._intersectedPath=null,this._perimeter.destroy(),this._perimeter=null,this._intersectedPerimeter.destroy(),this._intersectedPerimeter=null,this._areaLabel.destroy(),this._areaLabel=null,this._pathLengthLabel.destroy(),this._pathLengthLabel=null,this._cursorSegmentLengthLabel.destroy(),this._cursorSegmentLengthLabel=null,this._perimeterLengthLabel.destroy(),this._perimeterLengthLabel=null,this.set("view",null)}async whenMessages(){await(0,L.j)(this,"messages")}_update(){if(this.destroyed)return;const e=this.layerView.layerViewData.measurementData;(0,r.t)(e)||(this._updateViewData(e,this.layerView.layerViewData.path,this.layerView.layerViewData.cursorPoint),this._updateOrigin(),this._updatePathSegments(),this._updatePerimeterSegments(),this._updateArea(),this._updateProjectionLines(),this._updateLabels())}_updateViewData(e,t,i){const s=t.isValidPolygon,n=t.lastPoint,a=(0,r.r)(n)&&(0,r.r)(i)?new o.e(ue.segmentLengthGeodesic(n,i),"meters"):null,h=(0,r.r)(n)&&(0,r.r)(i)?new o.e(e.unitNormalizer.normalizeDistance(ue.segmentLengthEuclidean(n,i,e.unitNormalizer.spatialReference)),"meters"):null;let l;"auto"===this.mode?(l="euclidean",(e.geodesicPathLength?e.geodesicPathLength.value:0)+(!s&&(0,r.r)(a)?a.value:0)>this.geodesicMeasurementDistanceThreshold&&(l="geodesic")):l=this.mode,null==e.geodesicPathLength&&(l="euclidean");const u="geodesic"===l,p=u?e.geodesicArea:e.area;let g=1;if(p){const t=this._toPreferredAreaUnit(p,this.layerView.unit);g=(0,d.a8)(Math.sqrt(t.value)/Math.sqrt(300)),g*=Math.sqrt((0,c.I)(1,t.unit,"square-meters")),g/=e.unitNormalizer.normalizeDistance(1)}const m={validMeasurement:s,path:t,pathVersion:t.version,cursorPoint:i,measurementData:e,mode:l,positionsGeographic:e.positionsGeographic,positionsRenderCoords:e.positionsRenderCoords,positionsProjected:e.positionsProjectedWorldCoords,positionsFittedRenderCoords:e.positionsFittedRenderCoords,intersectingSegments:u?e.geodesicIntersectingSegments:e.intersectingSegments,triangleIndices:u?e.geodesicTriangleIndices:e.triangleIndices,fittingMode:e.fittingMode,areaCentroid:u?e.geodesicAreaCentroidRenderCoords:e.areaCentroidRenderCoords,pathLengthLabelSegmentIndex:s?0:t.numVertices-2,perimeterLengthLabelSegmentIndex:0,checkerSize:g,geodesicCursorSegmentLength:a,cursorSegmentLength:h};this._set("viewData",m)}_updateOrigin(){const e=this.viewData;(0,o.n)(e.positionsRenderCoords,this._origin),(0,C.r)(this._originTransform),(0,C.c)(this._originTransform,this._originTransform,this._origin),this._measurementArea.transform=this._originTransform,this._projectionLines.transform=this._originTransform}_createSegments(e){const t=this.viewData,i=t.path,s=this.view.renderCoordsHelper.spatialReference,r=t.mode,n=[],a=[],h=[],l=t.validMeasurement?i.numVertices:i.numVertices-1;for(let c=0;c<l;++c){const l=t[e][c],d=t[e][(c+1)%i.numVertices];let u=null;switch(r){case"euclidean":u=new o._(l,d);break;case"geodesic":u=new o.f(l,d,s)}t.intersectingSegments.has(c)?h.push(u):a.push(u),n.push(u)}return{all:n,nonIntersecting:a,intersecting:h}}_updatePathSegments(){const e=this.visible,t=this.viewData,i=this._createSegments("positionsRenderCoords"),s=t.path,n=!s.isValidPolygon,a=t.cursorPoint,h=this.view.renderCoordsHelper,l=h.spatialReference,c=t.mode;if(this._cursorSegment=null,s.numVertices>0&&n&&(0,r.r)(a)&&h.toRenderCoords(a,this._cursorPositionRenderSpace)){const e=t.positionsRenderCoords[s.numVertices-1],r=this._cursorPositionRenderSpace;let n=null;switch(c){case"euclidean":n=new o._(e,r);break;case"geodesic":n=new o.f(e,r,l)}i.nonIntersecting.push(n),this._cursorSegment=n}this._path.setGeometryFromSegments(i.nonIntersecting,this._origin),this._path.visible=e,this._intersectedPath.setGeometryFromSegments(i.intersecting,this._origin),this._intersectedPath.visible=e,this._pathSegments=i.all}_updatePerimeterSegments(){const e=this.visible&&"euclidean"===this.viewData.mode,t=this._createSegments("positionsFittedRenderCoords");this._perimeter.setGeometryFromSegments(t.nonIntersecting,this._origin),this._perimeter.visible=e,this._intersectedPerimeter.setGeometryFromSegments(t.intersecting,this._origin),this._intersectedPerimeter.visible=e,this._perimeterSegments=t.all}_updateArea(){const e=this.viewData;switch(e.mode){case"euclidean":this._updateAreaEuclidean(e);break;case"geodesic":this._updateAreaGeodesic()}}_updateAreaEuclidean(e){const t=this.visible;e.validMeasurement&&0===e.intersectingSegments.size&&e.triangleIndices?(this._measurementArea.geometry={uv:e.positionsProjected,position:e.positionsFittedRenderCoords,triangleIndices:e.triangleIndices},this._measurementArea.size=[e.checkerSize,e.checkerSize],this._measurementArea.visible=t):this._measurementArea.visible=!1}_updateAreaGeodesic(){this._measurementArea.visible=!1}_updateProjectionLines(){const e=this.viewData,t=this.visible,i=e.path,s=e.mode;if(i.numVertices>0&&e.validMeasurement&&"euclidean"===s){const s=[];for(let t=0;t<i.numVertices;++t){const i=(0,d.n)();(0,d.c)(i,e.positionsRenderCoords[t],this._origin);const r=(0,d.n)();(0,d.c)(r,e.positionsFittedRenderCoords[t],this._origin),s.push([i,r])}this._projectionLines.geometry=s,this._projectionLines.visible=t}else this._projectionLines.geometry=null,this._projectionLines.visible=!1}_updateLabels(){if(this.destroyed)return;const e=this.viewData,t=e.path;if(!t)return;const i=e.measurementData,s=e.mode,n=!t.isValidPolygon,o=this.visible,a=this._formatAreaLabel(this.messages,"geodesic"===s?i.geodesicArea:i.area,this.layerView.unit);(0,r.r)(a)?(this._areaLabel.geometry={type:"point",point:e.areaCentroid},this._areaLabel.text=a,this._areaLabel.visible=e.validMeasurement&&0===e.intersectingSegments.size&&o):this._areaLabel.visible=!1,this._set("areaLabel",(0,r.f)(a));const h=this._formatLengthLabel(this.messages,"geodesic"===s?i.geodesicPathLength:i.pathLength,this.layerView.unit);if((0,r.r)(h)&&e.pathLengthLabelSegmentIndex>=0&&e.pathLengthLabelSegmentIndex<this._pathSegments.length){const i=this._pathSegments[e.pathLengthLabelSegmentIndex],s=(0,r.r)(this._cursorSegment)?this._cursorSegment:Ve;this._pathLengthLabel.distance=this._params.labelDistance,this._pathLengthLabel.geometry={type:"corner",left:i,right:s},this._pathLengthLabel.text=h,this._pathLengthLabel.visible=n&&t.numVertices>0&&o}else this._pathLengthLabel.visible=!1;const l="geodesic"===s?e.geodesicCursorSegmentLength:e.cursorSegmentLength;if((0,r.r)(l)){const e=this._formatLengthLabel(this.messages,l,this.layerView.unit);this._cursorSegmentLengthLabel.distance=this._params.labelDistance,this._cursorSegmentLengthLabel.geometry=(0,r.r)(this._cursorSegment)?{type:"segment",segment:this._cursorSegment,sampleLocation:"end"}:null,this._cursorSegmentLengthLabel.anchor="bottom",this._cursorSegmentLengthLabel.text=(0,r.f)(e),this._cursorSegmentLengthLabel.visible=n&&0!==l.value&&o}else this._cursorSegmentLengthLabel.visible=!1;this._cursorSegmentLengthLabel.overlaps(this._pathLengthLabel)&&(this._cursorSegmentLengthLabel.visible=!1),this._pathLengthLabel.overlaps(this._areaLabel)&&(this._pathLengthLabel.visible=!1);const c="geodesic"===e.mode,d=c?i.geodesicPathLength:i.perimeterLength,u=(0,r.f)(null!=d?this._formatLengthLabel(this.messages,d,this.layerView.unit):null);if(this._set("perimeterLengthLabel",(0,r.f)(u)),e.validMeasurement&&0===e.intersectingSegments.size){this._perimeterLengthLabel.distance=this._params.labelDistance,this._perimeterLengthLabel.anchor="top",this._perimeterLengthLabel.text=u,this._perimeterLengthLabel.visible=!0;let t=!0;for(let i=0;i<e.path.numVertices;++i){const s=(e.perimeterLengthLabelSegmentIndex+i)%e.path.numVertices,r=c?this._pathSegments[s]:this._perimeterSegments[s];if(t=!0,this._perimeterLengthLabel.geometry={type:"segment",segment:r,sampleLocation:"center"},!this._perimeterLengthLabel.overlaps(this._areaLabel))break;t=!1}this._perimeterLengthLabel.visible=t&&o}else this._perimeterLengthLabel.visible=!1}_toPreferredAreaUnit(e,t){return e.toUnit(this._preferredAreaUnit(e,t))}_preferredAreaUnit(e,t){switch(t){case"metric":return(0,c.v)(e.value,e.unit);case"imperial":return(0,c.J)(e.value,e.unit);default:return t}}_preferredLengthUnit(e,t){const i=this._deriveLengthUnitFromAreaUnit(t);switch(i){case"metric":return(0,c.E)(e.value,e.unit);case"imperial":return(0,c.N)(e.value,e.unit);default:return i}}_deriveLengthUnitFromAreaUnit(e){switch(e){case"metric":return"metric";case"imperial":return"imperial";case"square-inches":return"inches";case"square-feet":return"feet";case"square-yards":return"yards";case"square-miles":return"miles";case"square-us-feet":return"us-feet";case"square-millimeters":return"millimeters";case"square-centimeters":return"centimeters";case"square-decimeters":return"decimeters";case"square-meters":return"meters";case"square-kilometers":return"kilometers";case"acres":return"imperial";case"ares":case"hectares":return"metric"}throw new Error("unhandled area unit")}_formatAreaLabel(e,t,i){return e&&t&&(0,o.l)(e,t,this._preferredAreaUnit(t,i))}_formatLengthLabel(e,t,i){return e&&t&&(0,o.l)(e,t,this._preferredLengthUnit(t,i))}_updateMessageBundle(){(0,P.a)("esri/core/t9n/Units").then((e=>{this.messages=e,this.view&&this._update()}))}};(0,s.e)([(0,n.y)()],Pe.prototype,"view",void 0),(0,s.e)([(0,n.y)()],Pe.prototype,"messages",void 0),(0,s.e)([(0,n.y)()],Pe.prototype,"analysis",void 0),(0,s.e)([(0,n.y)()],Pe.prototype,"viewData",void 0),(0,s.e)([(0,n.y)()],Pe.prototype,"layerView",void 0),(0,s.e)([(0,n.y)({readOnly:!0})],Pe.prototype,"areaLabel",void 0),(0,s.e)([(0,n.y)({readOnly:!0})],Pe.prototype,"perimeterLengthLabel",void 0),(0,s.e)([(0,n.y)()],Pe.prototype,"mode",void 0),(0,s.e)([(0,n.y)({readOnly:!0})],Pe.prototype,"visible",null),(0,s.e)([(0,n.y)()],Pe.prototype,"geodesicMeasurementDistanceThreshold",void 0),Pe=(0,s.e)([(0,n.n)("esri.views.3d.layers.analysis.AreaMeasurement.AreaMeasurementView")],Pe);const Ce={laserLineGlowColor:[1,.5,0],laserLineGlowWidth:8,laserLineGlowFalloff:8,laserLineInnerColor:[1,1,1],laserLineInnerWidth:1,laserLineGlobalAlpha:.75,laserLineEnabled:!0,handleColor:[1,.5,0],handleOpacity:.5,handleRadius:5,handleRadiusHovered:10,handleRadiusMouse:10,handleRadiusTouch:25,pathLineColor:[1,.5,0,1],pathLineWidth:3,intersectingLineColor:[1,.2,0,1],perimeterLineColor:[1,.5,0,1],perimeterLineWidth:2,projectionLineColor:[1,.5,0,1],projectionLineWidth:2,projectionLineStippleSize:5,areaColor1:[1,.5,0,.5],areaColor2:[1,1,1,.5],fillColor:[1,.5,0,.5],lineSubdivisions:64,labelDistance:25},xe={validMeasurement:!1,path:null,pathVersion:-1,cursorPoint:null,measurementData:null,mode:null,positionsGeographic:null,positionsRenderCoords:null,positionsProjected:null,positionsFittedRenderCoords:null,intersectingSegments:null,triangleIndices:null,fittingMode:null,areaCentroid:null,pathLengthLabelSegmentIndex:null,perimeterLengthLabelSegmentIndex:null,checkerSize:null,geodesicCursorSegmentLength:null,cursorSegmentLength:null},Ve=new o._((0,d.n)(),(0,d.n)());let ze=class extends((0,a.m)(A.d)){constructor(e){super(e),this.type="area-measurement-3d",this.layerViewData=new ne,this._userUnit=null}set unit(e){this._userUnit=e}get unit(){return(0,r.q)(this._userUnit,this._defaultUnit)}get result(){if((0,r.r)(this.layerViewData.measurementData)){const e=this.layerViewData.measurementData;return{area:e.area,geodesicArea:e.geodesicArea,pathLength:e.pathLength,geodesicPathLength:e.geodesicPathLength,perimeterLength:e.perimeterLength}}return{area:null,geodesicArea:null,pathLength:null,geodesicPathLength:null,perimeterLength:null}}initialize(){this.layerViewData.path.view=this.view,this.layerViewData.path.areaMeasurement=this.layer,this.analysisView=new Pe({view:this.view,analysis:this.layer,layerView:this}),this.analysisController=new W({view:this.view,analysis:this.layer,layerViewData:this.layerViewData})}destroy(){this.analysisController=(0,r.k)(this.analysisController),this.analysisView=(0,r.k)(this.analysisView)}get testData(){return{view:this.analysisView,controller:this.analysisController}}};(0,s.e)([(0,n.y)()],ze.prototype,"type",void 0),(0,s.e)([(0,n.y)()],ze.prototype,"analysisView",void 0),(0,s.e)([(0,n.y)()],ze.prototype,"analysisController",void 0),(0,s.e)([(0,n.y)()],ze.prototype,"unit",null),(0,s.e)([(0,n.y)()],ze.prototype,"layer",void 0),(0,s.e)([(0,n.y)()],ze.prototype,"result",null),(0,s.e)([(0,n.y)()],ze.prototype,"layerViewData",void 0),(0,s.e)([(0,n.y)(o.j)],ze.prototype,"_defaultUnit",void 0),(0,s.e)([(0,n.y)()],ze.prototype,"_userUnit",void 0),ze=(0,s.e)([(0,n.n)("esri.views.3d.layers.AreaMeasurementLayerView3D")],ze);var Me=ze,Re=Object.freeze({__proto__:null,default:Me})}}]);