import { c as g, f as n$2, e, p, y as y$2 } from './JSONSupport-9346590f.js';
import { L, C } from './Loadable-d16b3d7d.js';
import { s, v, m, g as g$1, h, b } from './promiseUtils-2ff2b194.js';
import { u } from './Handles-af859b7b.js';
import { y, n as n$1 } from './Message-70b34921.js';
import { e as e$1 } from './LRUCache-eed24cc2.js';
import { d } from './watchUtils-06a91cc9.js';
import { y as y$1, n as n$3 } from './subclass-fe5fcf78.js';
import { c } from './Point-ee7951c3.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
class l{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40;}getAvailability(t,i){if("unknown"!==this._allAvailability)return this._allAvailability;const e=(t-this.location.top)*this.location.width+(i-this.location.left),a=e%8,l=e>>3,o=this._tileAvailabilityBitSet;return l<0||l>o.length?"unknown":o[l]&1<<a?"available":"unavailable"}_updateFromData(t){const i=this.location.width,e=this.location.height;let a=!0,l=!0;const o=Math.ceil(i*e/8),n=new Uint8Array(o);let r=0;for(let s=0;s<t.length;s++){const i=s%8;t[s]?(l=!1,n[r]|=1<<i):a=!1,7===i&&++r;}l?this._allAvailability="unavailable":a?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=n,this.byteSize+=n.length);}static fromDefinition(a,o){const r=a.service.request||L,{row:s$1,col:h,width:c,height:m}=a,d={query:{f:"json"}};return o=o?{...d,...o}:d,r(n(a),o).then((t=>t.data)).catch((t=>{if(t&&t.details&&422===t.details.httpStatus)return {location:{top:s$1,left:h,width:c,height:m},valid:!0,data:g(c*m,0)};throw t})).then((t=>{if(t.location&&(t.location.top!==s$1||t.location.left!==h||t.location.width!==c||t.location.height!==m))throw new s("tilemap:location-mismatch","Tilemap response for different location than requested",{response:t,definition:{top:s$1,left:h,width:c,height:m}});return l.fromJSON(t)}))}static fromJSON(t){l.validateJSON(t);const i=new l;return i.location=Object.freeze(y(t.location)),i._updateFromData(t.data),Object.freeze(i)}static validateJSON(t){if(!t||!t.location)throw new s("tilemap:missing-location","Location missing from tilemap response");if(!1===t.valid)throw new s("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new s("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new s("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new s("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function o(t){return `${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function n(t){let i;if("vector-tile"===t.service.type)i=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;else {const e=t.service.tileServers;i=`${e&&e.length?e[t.row%e.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;}const e=t.service.query;return e&&(i=`${i}?${e}`),i}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.20/esri/copyright.txt for details.
*/
var w;const T=n$1.getLogger("esri.layers.support.TilemapCache");let j=w=class extends p{constructor(e){super(e),this._handles=new u,this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=L,this._prefetchingEnabled=!0;}initialize(){this._tilemapCache=new e$1(this.cacheByteSize),this._handles.add([this.watch(["layer.parsedUrl","layer.tileServers?"],(()=>this._initializeTilemapDefinition())),d(this,"layer.tileInfo.lods",(e=>this._initializeAvailableLevels(e)),!0)]),this._initializeTilemapDefinition();}destroy(){this._handles&&(this._handles.destroy(),this._handles=null);}castLevels(e){return e<=2?(T.error("Minimum levels for Tilemap is 3, but got ",e),3):e}get size(){return 1<<this.levels}fetchTilemap(e,t,i,r){if(!this._availableLevels[e])return Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const s$1=this._tmpTilemapDefinition,a=this._tilemapFromCache(e,t,i,s$1);if(a)return Promise.resolve(a);const o$1=r&&r.signal;return r={...r,signal:null},new Promise(((e,t)=>{v(o$1,(()=>t(m())));const i=o(s$1);let l$1=this._pendingTilemapRequests[i];if(!l$1){l$1=l.fromDefinition(s$1,r).then((e=>(this._tilemapCache.put(i,e,e.byteSize),e)));const e=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=l$1,l$1.then(e,e);}l$1.then(e,t);}))}getAvailability(e,t,i){if(!this._availableLevels[e])return "unavailable";const l=this._tilemapFromCache(e,t,i,this._tmpTilemapDefinition);return l?l.getAvailability(t,i):"unknown"}getAvailabilityUpsample(e,t,i,l){l.level=e,l.row=t,l.col=i;const r=this.layer.tileInfo;for(r.updateTileInfo(l);;){const e=this.getAvailability(l.level,l.row,l.col);if("unavailable"!==e)return e;if(!r.upsampleTile(l))return "unavailable"}}fetchAvailability(e,t,i,r){return this._availableLevels[e]?this.fetchTilemap(e,t,i,r).catch((e=>e)).then((r=>{if(r instanceof l){const s$1=r.getAvailability(t,i);return "unavailable"===s$1?Promise.reject(new s("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:i})):s$1}if(g$1(r))throw r;return "unknown"})):Promise.reject(new s("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`))}fetchAvailabilityUpsample(e,t,i,l,r){l.level=e,l.row=t,l.col=i;const s=this.layer.tileInfo;s.updateTileInfo(l);const a=this.fetchAvailability(e,t,i,r).catch((e=>{if(g$1(e))throw e;if(s.upsampleTile(l))return this.fetchAvailabilityUpsample(l.level,l.row,l.col,l);throw e}));return this._fetchAvailabilityUpsamplePrefetch(l.id,e,t,i,r,a),a}async _fetchAvailabilityUpsamplePrefetch(e,t,i,l,r,s){if(!this._prefetchingEnabled)return;const a=`prefetch-${e}`;if(this._handles.has(a))return;const o=h();s.then((()=>o.abort()),(()=>o.abort()));let n=!1;const c={remove(){n||(n=!0,o.abort());}};if(this._handles.add(c,a),await y$2(10,o.signal).catch((()=>{})),n||(n=!0,this._handles.remove(a)),b(o))return;const h$1={id:e,level:t,row:i,col:l},f={...r,signal:o.signal},v=this.layer.tileInfo;for(let p=0;w._prefetches.length<w._maxPrefetch&&v.upsampleTile(h$1);++p){const e=this.fetchAvailability(h$1.level,h$1.row,h$1.col,f);w._prefetches.push(e);const t=()=>{w._prefetches.removeUnordered(e);};e.then(t,t);}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const e=this.layer.parsedUrl,t=e.query;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:t?C(t):null,tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0};}_tilemapFromCache(e,t,i,l){l.level=e,l.row=t-t%this.size,l.col=i-i%this.size;const r=o(l);return this._tilemapCache.get(r)}_initializeAvailableLevels(e){this._availableLevels={},e&&e.forEach((e=>this._availableLevels[e.level]=!0));}get test(){const e=this;return {get prefetchingEnabled(){return e._prefetchingEnabled},set prefetchingEnabled(t){e._prefetchingEnabled=t;},hasTilemap:(t,i,l)=>!!e._tilemapFromCache(t,i,l,e._tmpTilemapDefinition)}}};j._maxPrefetch=4,j._prefetches=new n$2({initialSize:w._maxPrefetch}),e([y$1({constructOnly:!0,type:Number})],j.prototype,"levels",void 0),e([c("levels")],j.prototype,"castLevels",null),e([y$1({readOnly:!0,type:Number})],j.prototype,"size",null),e([y$1({constructOnly:!0,type:Number})],j.prototype,"cacheByteSize",void 0),e([y$1({constructOnly:!0})],j.prototype,"layer",void 0),e([y$1({constructOnly:!0})],j.prototype,"request",void 0),j=w=e([n$3("esri.layers.support.TilemapCache")],j);

export { j };
